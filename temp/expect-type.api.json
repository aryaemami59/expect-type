{
  "metadata": {
    "toolPackage": "@microsoft/api-extractor",
    "toolVersion": "7.50.0",
    "schemaVersion": 1011,
    "oldestForwardsCompatibleVersion": 1001,
    "tsdocConfig": {
      "$schema": "https://developer.microsoft.com/json-schemas/tsdoc/v0/tsdoc.schema.json",
      "noStandardTags": true,
      "tagDefinitions": [
        {
          "tagName": "@alpha",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@beta",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@defaultValue",
          "syntaxKind": "block"
        },
        {
          "tagName": "@decorator",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@deprecated",
          "syntaxKind": "block"
        },
        {
          "tagName": "@eventProperty",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@example",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@experimental",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@inheritDoc",
          "syntaxKind": "inline"
        },
        {
          "tagName": "@internal",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@label",
          "syntaxKind": "inline"
        },
        {
          "tagName": "@link",
          "syntaxKind": "inline",
          "allowMultiple": true
        },
        {
          "tagName": "@override",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@packageDocumentation",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@param",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@privateRemarks",
          "syntaxKind": "block"
        },
        {
          "tagName": "@public",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@readonly",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@remarks",
          "syntaxKind": "block"
        },
        {
          "tagName": "@returns",
          "syntaxKind": "block"
        },
        {
          "tagName": "@sealed",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@see",
          "syntaxKind": "block"
        },
        {
          "tagName": "@throws",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@typeParam",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@virtual",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@betaDocumentation",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@internalRemarks",
          "syntaxKind": "block"
        },
        {
          "tagName": "@preapproved",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@default",
          "syntaxKind": "block"
        },
        {
          "tagName": "@linkcode",
          "syntaxKind": "inline",
          "allowMultiple": true
        },
        {
          "tagName": "@extends",
          "syntaxKind": "block"
        },
        {
          "tagName": "@description",
          "syntaxKind": "block"
        }
      ],
      "supportForTags": {
        "@alpha": true,
        "@beta": true,
        "@defaultValue": true,
        "@decorator": true,
        "@deprecated": true,
        "@eventProperty": true,
        "@example": true,
        "@experimental": true,
        "@inheritDoc": true,
        "@internal": true,
        "@label": true,
        "@link": true,
        "@override": true,
        "@packageDocumentation": true,
        "@param": true,
        "@privateRemarks": true,
        "@public": true,
        "@readonly": true,
        "@remarks": true,
        "@returns": true,
        "@sealed": true,
        "@see": true,
        "@throws": true,
        "@typeParam": true,
        "@virtual": true,
        "@betaDocumentation": true,
        "@internalRemarks": true,
        "@preapproved": true,
        "@default": true,
        "@linkcode": true,
        "@extends": true,
        "@description": true
      },
      "reportUnsupportedHtmlElements": false
    }
  },
  "projectFolderUrl": "https://github.com/mmkal/expect-type/tree/main",
  "kind": "Package",
  "canonicalReference": "expect-type!",
  "docComment": "",
  "name": "expect-type",
  "preserveMemberOrder": false,
  "members": [
    {
      "kind": "EntryPoint",
      "canonicalReference": "expect-type!",
      "name": "",
      "preserveMemberOrder": false,
      "members": [
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!_ExpectTypeOf:type",
          "docComment": "/**\n * Represents a function that allows asserting the expected type of a value.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type _ExpectTypeOf = "
            },
            {
              "kind": "Content",
              "text": "{\n    <Actual>(actual: Actual): "
            },
            {
              "kind": "Reference",
              "text": "ExpectTypeOf",
              "canonicalReference": "expect-type!ExpectTypeOf:type"
            },
            {
              "kind": "Content",
              "text": "<Actual, {\n        positive: true;\n        branded: false;\n    }>;\n    <Actual>(): "
            },
            {
              "kind": "Reference",
              "text": "ExpectTypeOf",
              "canonicalReference": "expect-type!ExpectTypeOf:type"
            },
            {
              "kind": "Content",
              "text": "<Actual, {\n        positive: true;\n        branded: false;\n    }>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/index.d.ts",
          "releaseTag": "Public",
          "name": "_ExpectTypeOf",
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!And:type",
          "docComment": "/**\n * Checks if all the boolean types in the {@linkcode Types} array are `true`.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type And<Types extends "
            },
            {
              "kind": "Content",
              "text": "boolean[]"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "Types[number] extends true ? true : false"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "And",
          "typeParameters": [
            {
              "typeParameterName": "Types",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 3,
            "endIndex": 4
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!AValue:type",
          "docComment": "/**\n * Represents a value that can be of various types.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type AValue = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "avalue",
              "canonicalReference": "expect-type!~avalue:var"
            },
            {
              "kind": "Content",
              "text": "]?: undefined;\n} | string | number | boolean | symbol | bigint | null | undefined | void"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "AValue",
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 4
          }
        },
        {
          "kind": "Interface",
          "canonicalReference": "expect-type!BaseExpectTypeOf:interface",
          "docComment": "/**\n * Represents the base interface for the {@linkcode expectTypeOf()} function. Provides a set of assertion methods to perform type checks on a value.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface BaseExpectTypeOf<Actual, Options extends "
            },
            {
              "kind": "Content",
              "text": "{\n    positive: boolean;\n}"
            },
            {
              "kind": "Content",
              "text": "> "
            }
          ],
          "fileUrlPath": "dist/index.d.ts",
          "releaseTag": "Public",
          "typeParameters": [
            {
              "typeParameterName": "Actual",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "Options",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "BaseExpectTypeOf",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#asserts:member",
              "docComment": "/**\n * Extracts the type asserted by a function to perform assertions on.\n *\n * @example\n * ```ts\n * function assertNumber(v: any): asserts v is number {\n *   if (typeof v !== 'number')\n *     throw new TypeError('Nope !')\n * }\n *\n * expectTypeOf(assertNumber).asserts.toBeNumber()\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "asserts: "
                },
                {
                  "kind": "Content",
                  "text": "Actual extends (v: any, ...args: any[]) => asserts "
                },
                {
                  "kind": "Reference",
                  "text": "v",
                  "canonicalReference": "expect-type!~v"
                },
                {
                  "kind": "Content",
                  "text": " is infer T ? unknown extends T ? never : "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<T, Options> : never"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "asserts",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#constructorParameters:member",
              "docComment": "/**\n * Equivalent to the {@linkcode ConstructorParameters} utility type. Extracts constructor parameters as an array of values and perform assertions on them with this method.\n *\n * For overloaded constructors it will return a union of all possible parameter-tuples.\n *\n * @example\n * ```ts\n * expectTypeOf(Date).constructorParameters.toEqualTypeOf<\n *   [] | [string | number | Date]\n * >()\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "constructorParameters: "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ConstructorOverloadParameters",
                  "canonicalReference": "expect-type!ConstructorOverloadParameters:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "constructorParameters",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#exclude:member",
              "docComment": "/**\n * Equivalent to the {@linkcode Exclude} utility type. Removes types from a union.\n *\n * @example\n * ```ts\n * type ResponsiveProp<T> = T | T[] | { xs?: T; sm?: T; md?: T }\n *\n * interface CSSProperties {\n *   margin?: string\n *   padding?: string\n * }\n *\n * function getResponsiveProp<T>(_props: T): ResponsiveProp<T> {\n *   return {}\n * }\n *\n * const cssProperties: CSSProperties = { margin: '1px', padding: '2px' }\n *\n * expectTypeOf(getResponsiveProp(cssProperties))\n *   .exclude<unknown[]>()\n *   .exclude<{ xs?: unknown }>() // or just `.exclude<unknown[] | { xs?: unknown }>()`\n *   .toEqualTypeOf<CSSProperties>()\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "exclude: "
                },
                {
                  "kind": "Content",
                  "text": "<V>(v?: V) => "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Exclude",
                  "canonicalReference": "!Exclude:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, V>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "exclude",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#extract:member",
              "docComment": "/**\n * Equivalent to the {@linkcode Extract} utility type. Helps narrow down complex union types.\n *\n * @param v - The type to extract from the union.\n *\n * @returns The type after extracting the type from the union.\n *\n * @example\n * ```ts\n * type ResponsiveProp<T> = T | T[] | { xs?: T; sm?: T; md?: T }\n *\n * interface CSSProperties {\n *   margin?: string\n *   padding?: string\n * }\n *\n * function getResponsiveProp<T>(_props: T): ResponsiveProp<T> {\n *   return {}\n * }\n *\n * const cssProperties: CSSProperties = { margin: '1px', padding: '2px' }\n *\n * expectTypeOf(getResponsiveProp(cssProperties))\n *   .extract<{ xs?: any }>() // extracts the last type from a union\n *   .toEqualTypeOf<{\n *     xs?: CSSProperties\n *     sm?: CSSProperties\n *     md?: CSSProperties\n *   }>()\n *\n * expectTypeOf(getResponsiveProp(cssProperties))\n *   .extract<unknown[]>() // extracts an array from a union\n *   .toEqualTypeOf<CSSProperties[]>()\n * ```\n *\n * __Note__: If no type is found in the union, it will return `never`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "extract: "
                },
                {
                  "kind": "Content",
                  "text": "<V>(v?: V) => "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Extract",
                  "canonicalReference": "!Extract:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, V>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "extract",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#guards:member",
              "docComment": "/**\n * Extracts the type guarded by a function to perform assertions on.\n *\n * @example\n * ```ts\n * function isString(v: any): v is string {\n *   return typeof v === 'string'\n * }\n *\n * expectTypeOf(isString).guards.toBeString()\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "guards: "
                },
                {
                  "kind": "Content",
                  "text": "Actual extends (v: any, ...args: any[]) => "
                },
                {
                  "kind": "Reference",
                  "text": "v",
                  "canonicalReference": "expect-type!~v"
                },
                {
                  "kind": "Content",
                  "text": " is infer T ? "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<T, Options> : never"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "guards",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#instance:member",
              "docComment": "/**\n * Equivalent to the {@linkcode InstanceType} utility type. Extracts the instance type of a class to perform assertions on.\n *\n * @example\n * ```ts\n * expectTypeOf(Date).instance.toHaveProperty('toISOString')\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "instance: "
                },
                {
                  "kind": "Content",
                  "text": "Actual extends new (...args: any[]) => infer I ? "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<I, Options> : never"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "instance",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#items:member",
              "docComment": "/**\n * Extracts array item type to perform assertions on.\n *\n * @example\n * ```ts\n * expectTypeOf([1, 2, 3]).items.toEqualTypeOf<number>()\n *\n * expectTypeOf([1, 2, 3]).items.not.toEqualTypeOf<string>()\n * ```\n *\n * __Type Equivalent__:\n * ```ts\n * type Items<ArrayType> = ArrayType extends ArrayLike<infer ItemType>\n *   ? ItemType\n *   : never\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "items: "
                },
                {
                  "kind": "Content",
                  "text": "Actual extends "
                },
                {
                  "kind": "Reference",
                  "text": "ArrayLike",
                  "canonicalReference": "!ArrayLike:interface"
                },
                {
                  "kind": "Content",
                  "text": "<infer ItemType> ? "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<ItemType, Options> : never"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "items",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#omit:member",
              "docComment": "/**\n * Equivalent to the {@linkcode Omit} utility type. Helps remove a subset of properties from an object type.\n *\n * @param keyToOmit - The property key to omit.\n *\n * @returns The type after omitting the property.\n *\n * @example\n * ```ts\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * expectTypeOf<Person>().omit<'name'>().toEqualTypeOf<{ age: number }>()\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "omit: "
                },
                {
                  "kind": "Content",
                  "text": "<KeyToOmit extends keyof Actual | ("
                },
                {
                  "kind": "Reference",
                  "text": "PropertyKey",
                  "canonicalReference": "!PropertyKey:type"
                },
                {
                  "kind": "Content",
                  "text": " & "
                },
                {
                  "kind": "Reference",
                  "text": "Record",
                  "canonicalReference": "!Record:type"
                },
                {
                  "kind": "Content",
                  "text": "<never, never>)>(keyToOmit?: KeyToOmit) => "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Omit",
                  "canonicalReference": "!Omit:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, KeyToOmit>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "omit",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 10
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#parameter:member",
              "docComment": "/**\n * Extracts a certain function argument with `.parameter(number)` call to perform other assertions on it.\n *\n * @param index - The index of the parameter to extract.\n *\n * @returns The extracted parameter type.\n *\n * @example\n * ```ts\n * function foo(a: number, b: string) {\n *   return [a, b]\n * }\n *\n * expectTypeOf(foo).parameter(0).toBeNumber()\n *\n * expectTypeOf(foo).parameter(1).toBeString()\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "parameter: "
                },
                {
                  "kind": "Content",
                  "text": "<Index extends number>(index: Index) => "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "OverloadParameters",
                  "canonicalReference": "expect-type!OverloadParameters:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>[Index], Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "parameter",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#parameters:member",
              "docComment": "/**\n * Equivalent to the {@linkcode Parameters} utility type. Extracts function parameters to perform assertions on its value. Parameters are returned as an array.\n *\n * @example\n * ```ts\n * function noParam() {}\n *\n * function hasParam(s: string) {}\n *\n * expectTypeOf(noParam).parameters.toEqualTypeOf<[]>()\n *\n * expectTypeOf(hasParam).parameters.toEqualTypeOf<[string]>()\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "parameters: "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "OverloadParameters",
                  "canonicalReference": "expect-type!OverloadParameters:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "parameters",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#pick:member",
              "docComment": "/**\n * Equivalent to the {@linkcode Pick} utility type. Helps select a subset of properties from an object type.\n *\n * @param keyToPick - The property key to pick.\n *\n * @returns The type after picking the property.\n *\n * @example\n * ```ts\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * expectTypeOf<Person>()\n *   .pick<'name'>()\n *   .toEqualTypeOf<{ name: string }>()\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "pick: "
                },
                {
                  "kind": "Content",
                  "text": "<KeyToPick extends keyof Actual>(keyToPick?: KeyToPick) => "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Pick",
                  "canonicalReference": "!Pick:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, KeyToPick>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "pick",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#positive:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "positive: "
                },
                {
                  "kind": "Content",
                  "text": "boolean"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "positive",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#resolves:member",
              "docComment": "/**\n * Extracts resolved value of a Promise, so you can perform other assertions on it.\n *\n * @example\n * ```ts\n * async function asyncFunc() {\n *   return 123\n * }\n *\n * expectTypeOf(asyncFunc).returns.resolves.toBeNumber()\n *\n * expectTypeOf(Promise.resolve('string')).resolves.toBeString()\n * ```\n *\n * Type Equivalent:\n * ```ts\n * type Resolves<PromiseType> = PromiseType extends PromiseLike<infer ResolvedType>\n *   ? ResolvedType\n *   : never\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "resolves: "
                },
                {
                  "kind": "Content",
                  "text": "Actual extends "
                },
                {
                  "kind": "Reference",
                  "text": "PromiseLike",
                  "canonicalReference": "!PromiseLike:interface"
                },
                {
                  "kind": "Content",
                  "text": "<infer ResolvedType> ? "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<ResolvedType, Options> : never"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "resolves",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#returns:member",
              "docComment": "/**\n * Equivalent to the {@linkcode ReturnType} utility type. Extracts the return type of a function.\n *\n * @example\n * ```ts\n * expectTypeOf(() => {}).returns.toBeVoid()\n *\n * expectTypeOf((a: number) => [a, a]).returns.toEqualTypeOf([1, 2])\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "returns: "
                },
                {
                  "kind": "Content",
                  "text": "Actual extends "
                },
                {
                  "kind": "Reference",
                  "text": "Function",
                  "canonicalReference": "!Function:interface"
                },
                {
                  "kind": "Content",
                  "text": " ? "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "OverloadReturnTypes",
                  "canonicalReference": "expect-type!OverloadReturnTypes:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options> : never"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "returns",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 8
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#thisParameter:member",
              "docComment": "/**\n * Equivalent to the {@linkcode ThisParameterType} utility type. Extracts the `this` parameter of a function to perform assertions on its value.\n *\n * @example\n * ```ts\n * function greet(this: { name: string }, message: string) {\n *   return `Hello ${this.name}, here's your message: ${message}`\n * }\n *\n * expectTypeOf(greet).thisParameter.toEqualTypeOf<{ name: string }>()\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "thisParameter: "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ThisParameterType",
                  "canonicalReference": "!ThisParameterType:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "thisParameter",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeAny:member",
              "docComment": "/**\n * Checks whether the type of the value is `any`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeAny: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectAny",
                  "canonicalReference": "expect-type!ExpectAny:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeAny",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeArray:member",
              "docComment": "/**\n * Checks whether the type of the value is an {@linkcode Array}.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeArray: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectArray",
                  "canonicalReference": "expect-type!ExpectArray:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeArray",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeBigInt:member",
              "docComment": "/**\n * Checks whether the type of the value is **`bigint`**.\n *\n * @example\n *\n * <caption>#### Distinguish between **`number`** and **`bigint`**</caption>\n * ```ts\n * import { expectTypeOf } from 'expect-type'\n *\n * const aVeryBigInteger = 10n ** 100n\n *\n * expectTypeOf(aVeryBigInteger).not.toBeNumber()\n *\n * expectTypeOf(aVeryBigInteger).toBeBigInt()\n * ```\n *\n * @since 1.1.0\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeBigInt: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectBigInt",
                  "canonicalReference": "expect-type!ExpectBigInt:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeBigInt",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeBoolean:member",
              "docComment": "/**\n * Checks whether the type of the value is `boolean`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeBoolean: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectBoolean",
                  "canonicalReference": "expect-type!ExpectBoolean:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeBoolean",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeCallableWith:member",
              "docComment": "/**\n * Checks whether a function is callable with the given parameters.\n *\n * __Note__: You cannot negate this assertion with {@linkcode PositiveExpectTypeOf.not | .not}, you need to use `ts-expect-error` instead.\n *\n * @param args - The arguments to check for callability.\n *\n * @returns `true`.\n *\n * @example\n * ```ts\n * const f = (a: number) => [a, a]\n *\n * expectTypeOf(f).toBeCallableWith(1)\n * ```\n *\n * __Known Limitation__: This assertion will likely fail if you try to use it with a generic function or an overload.\n *\n * @see\n *\n * {@link https://github.com/mmkal/expect-type/issues/50 | This issue} for an example and a workaround.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeCallableWith: "
                },
                {
                  "kind": "Content",
                  "text": "Options['positive'] extends true ? <Args extends "
                },
                {
                  "kind": "Reference",
                  "text": "OverloadParameters",
                  "canonicalReference": "expect-type!OverloadParameters:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>>(...args: Args) => "
                },
                {
                  "kind": "Reference",
                  "text": "ExpectTypeOf",
                  "canonicalReference": "expect-type!ExpectTypeOf:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "OverloadsNarrowedByParameters",
                  "canonicalReference": "expect-type!OverloadsNarrowedByParameters:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Args>, Options> : never"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeCallableWith",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 8
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeConstructibleWith:member",
              "docComment": "/**\n * Checks whether a class is constructible with the given parameters.\n *\n * @param args - The arguments to check for constructibility.\n *\n * @returns `true`.\n *\n * @example\n * ```ts\n * expectTypeOf(Date).toBeConstructibleWith('1970')\n *\n * expectTypeOf(Date).toBeConstructibleWith(0)\n *\n * expectTypeOf(Date).toBeConstructibleWith(new Date())\n *\n * expectTypeOf(Date).toBeConstructibleWith()\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeConstructibleWith: "
                },
                {
                  "kind": "Content",
                  "text": "Options['positive'] extends true ? <Args extends "
                },
                {
                  "kind": "Reference",
                  "text": "ConstructorOverloadParameters",
                  "canonicalReference": "expect-type!ConstructorOverloadParameters:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>>(...args: Args) => true : never"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeConstructibleWith",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeFunction:member",
              "docComment": "/**\n * Checks whether the type of the value is `function`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeFunction: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectFunction",
                  "canonicalReference": "expect-type!ExpectFunction:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeFunction",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeNever:member",
              "docComment": "/**\n * Checks whether the type of the value is `never`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeNever: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectNever",
                  "canonicalReference": "expect-type!ExpectNever:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeNever",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeNull:member",
              "docComment": "/**\n * Checks whether the type of the value is `null`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeNull: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectNull",
                  "canonicalReference": "expect-type!ExpectNull:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeNull",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeNullable:member",
              "docComment": "/**\n * Checks whether the type of the value is `null` or `undefined`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeNullable: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectNullable",
                  "canonicalReference": "expect-type!ExpectNullable:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeNullable",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeNumber:member",
              "docComment": "/**\n * Checks whether the type of the value is `number`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeNumber: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectNumber",
                  "canonicalReference": "expect-type!ExpectNumber:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeNumber",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeObject:member",
              "docComment": "/**\n * Checks whether the type of the value is `object`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeObject: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectObject",
                  "canonicalReference": "expect-type!ExpectObject:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeObject",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeString:member",
              "docComment": "/**\n * Checks whether the type of the value is `string`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeString: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectString",
                  "canonicalReference": "expect-type!ExpectString:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeString",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeSymbol:member",
              "docComment": "/**\n * Checks whether the type of the value is `symbol`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeSymbol: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectSymbol",
                  "canonicalReference": "expect-type!ExpectSymbol:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeSymbol",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeUndefined:member",
              "docComment": "/**\n * Checks whether the type of the value is `undefined`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeUndefined: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectUndefined",
                  "canonicalReference": "expect-type!ExpectUndefined:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeUndefined",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeUnknown:member",
              "docComment": "/**\n * Checks whether the type of the value is `unknown`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeUnknown: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectUnknown",
                  "canonicalReference": "expect-type!ExpectUnknown:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeUnknown",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!BaseExpectTypeOf#toBeVoid:member",
              "docComment": "/**\n * Checks whether the type of the value is `void`.\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toBeVoid: "
                },
                {
                  "kind": "Reference",
                  "text": "Scolder",
                  "canonicalReference": "expect-type!Scolder:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "ExpectVoid",
                  "canonicalReference": "expect-type!ExpectVoid:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>, Options>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toBeVoid",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 5
              }
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ConstructorOverloadParameters:type",
          "docComment": "/**\n * A union type of the parameters allowed for any overload of constructor {@linkcode ConstructorType}.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ConstructorOverloadParameters<ConstructorType> = "
            },
            {
              "kind": "Reference",
              "text": "ConstructorOverloadsUnion",
              "canonicalReference": "expect-type!ConstructorOverloadsUnion:type"
            },
            {
              "kind": "Content",
              "text": "<ConstructorType> extends "
            },
            {
              "kind": "Reference",
              "text": "InferConstructor",
              "canonicalReference": "expect-type!InferConstructor:type"
            },
            {
              "kind": "Content",
              "text": "<infer Ctor> ? "
            },
            {
              "kind": "Reference",
              "text": "ConstructorParameters",
              "canonicalReference": "!ConstructorParameters:type"
            },
            {
              "kind": "Content",
              "text": "<Ctor> : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "ConstructorOverloadParameters",
          "typeParameters": [
            {
              "typeParameterName": "ConstructorType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ConstructorOverloadsUnion:type",
          "docComment": "/**\n * Get a union of overload variants for a constructor {@linkcode ConstructorType}. Does a check for whether we can do the one-shot 10-overload matcher (which works for ts\\>5.3), and if not, falls back to the more complicated utility.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ConstructorOverloadsUnion<ConstructorType> = "
            },
            {
              "kind": "Reference",
              "text": "IsNever",
              "canonicalReference": "expect-type!IsNever:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TSPost53ConstructorOverloadsInfoUnion",
              "canonicalReference": "expect-type!TSPost53ConstructorOverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<new (a: 1) => any>> extends true ? "
            },
            {
              "kind": "Reference",
              "text": "TSPre53ConstructorOverloadsInfoUnion",
              "canonicalReference": "expect-type!TSPre53ConstructorOverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<ConstructorType> : "
            },
            {
              "kind": "Reference",
              "text": "TSPost53ConstructorOverloadsInfoUnion",
              "canonicalReference": "expect-type!TSPost53ConstructorOverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<ConstructorType>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "ConstructorOverloadsUnion",
          "typeParameters": [
            {
              "typeParameterName": "ConstructorType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 9
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!DecreasingConstructorOverloadsInfoUnion:type",
          "docComment": "/**\n * For versions of TypeScript below 5.3, we need to check for 10 overloads, then 9, then 8, etc., to get a union of the overload variants.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type DecreasingConstructorOverloadsInfoUnion<ConstructorType> = "
            },
            {
              "kind": "Content",
              "text": "ConstructorType extends {\n    new (...args: infer A1): infer R1;\n    new (...args: infer A2): infer R2;\n    new (...args: infer A3): infer R3;\n    new (...args: infer A4): infer R4;\n    new (...args: infer A5): infer R5;\n    new (...args: infer A6): infer R6;\n    new (...args: infer A7): infer R7;\n    new (...args: infer A8): infer R8;\n    new (...args: infer A9): infer R9;\n    new (...args: infer A10): infer R10;\n} ? (new (...p: A1) => R1) | (new (...p: A2) => R2) | (new (...p: A3) => R3) | (new (...p: A4) => R4) | (new (...p: A5) => R5) | (new (...p: A6) => R6) | (new (...p: A7) => R7) | (new (...p: A8) => R8) | (new (...p: A9) => R9) | (new (...p: A10) => R10) : ConstructorType extends {\n    new (...args: infer A1): infer R1;\n    new (...args: infer A2): infer R2;\n    new (...args: infer A3): infer R3;\n    new (...args: infer A4): infer R4;\n    new (...args: infer A5): infer R5;\n    new (...args: infer A6): infer R6;\n    new (...args: infer A7): infer R7;\n    new (...args: infer A8): infer R8;\n    new (...args: infer A9): infer R9;\n} ? (new (...p: A1) => R1) | (new (...p: A2) => R2) | (new (...p: A3) => R3) | (new (...p: A4) => R4) | (new (...p: A5) => R5) | (new (...p: A6) => R6) | (new (...p: A7) => R7) | (new (...p: A8) => R8) | (new (...p: A9) => R9) : ConstructorType extends {\n    new (...args: infer A1): infer R1;\n    new (...args: infer A2): infer R2;\n    new (...args: infer A3): infer R3;\n    new (...args: infer A4): infer R4;\n    new (...args: infer A5): infer R5;\n    new (...args: infer A6): infer R6;\n    new (...args: infer A7): infer R7;\n    new (...args: infer A8): infer R8;\n} ? (new (...p: A1) => R1) | (new (...p: A2) => R2) | (new (...p: A3) => R3) | (new (...p: A4) => R4) | (new (...p: A5) => R5) | (new (...p: A6) => R6) | (new (...p: A7) => R7) | (new (...p: A8) => R8) : ConstructorType extends {\n    new (...args: infer A1): infer R1;\n    new (...args: infer A2): infer R2;\n    new (...args: infer A3): infer R3;\n    new (...args: infer A4): infer R4;\n    new (...args: infer A5): infer R5;\n    new (...args: infer A6): infer R6;\n    new (...args: infer A7): infer R7;\n} ? (new (...p: A1) => R1) | (new (...p: A2) => R2) | (new (...p: A3) => R3) | (new (...p: A4) => R4) | (new (...p: A5) => R5) | (new (...p: A6) => R6) | (new (...p: A7) => R7) : ConstructorType extends {\n    new (...args: infer A1): infer R1;\n    new (...args: infer A2): infer R2;\n    new (...args: infer A3): infer R3;\n    new (...args: infer A4): infer R4;\n    new (...args: infer A5): infer R5;\n    new (...args: infer A6): infer R6;\n} ? (new (...p: A1) => R1) | (new (...p: A2) => R2) | (new (...p: A3) => R3) | (new (...p: A4) => R4) | (new (...p: A5) => R5) | (new (...p: A6) => R6) : ConstructorType extends {\n    new (...args: infer A1): infer R1;\n    new (...args: infer A2): infer R2;\n    new (...args: infer A3): infer R3;\n    new (...args: infer A4): infer R4;\n    new (...args: infer A5): infer R5;\n} ? (new (...p: A1) => R1) | (new (...p: A2) => R2) | (new (...p: A3) => R3) | (new (...p: A4) => R4) | (new (...p: A5) => R5) : ConstructorType extends {\n    new (...args: infer A1): infer R1;\n    new (...args: infer A2): infer R2;\n    new (...args: infer A3): infer R3;\n    new (...args: infer A4): infer R4;\n} ? (new (...p: A1) => R1) | (new (...p: A2) => R2) | (new (...p: A3) => R3) | (new (...p: A4) => R4) : ConstructorType extends {\n    new (...args: infer A1): infer R1;\n    new (...args: infer A2): infer R2;\n    new (...args: infer A3): infer R3;\n} ? (new (...p: A1) => R1) | (new (...p: A2) => R2) | (new (...p: A3) => R3) : ConstructorType extends {\n    new (...args: infer A1): infer R1;\n    new (...args: infer A2): infer R2;\n} ? (new (...p: A1) => R1) | (new (...p: A2) => R2) : ConstructorType extends new (...args: infer A1) => infer R1 ? (new (...p: A1) => R1) : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "DecreasingConstructorOverloadsInfoUnion",
          "typeParameters": [
            {
              "typeParameterName": "ConstructorType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!DecreasingOverloadsInfoUnion:type",
          "docComment": "/**\n * For versions of TypeScript below 5.3, we need to check for 10 overloads, then 9, then 8, etc., to get a union of the overload variants.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type DecreasingOverloadsInfoUnion<F> = "
            },
            {
              "kind": "Content",
              "text": "F extends {\n    (...args: infer A1): infer R1;\n    (...args: infer A2): infer R2;\n    (...args: infer A3): infer R3;\n    (...args: infer A4): infer R4;\n    (...args: infer A5): infer R5;\n    (...args: infer A6): infer R6;\n    (...args: infer A7): infer R7;\n    (...args: infer A8): infer R8;\n    (...args: infer A9): infer R9;\n    (...args: infer A10): infer R10;\n} ? ((...p: A1) => R1) | ((...p: A2) => R2) | ((...p: A3) => R3) | ((...p: A4) => R4) | ((...p: A5) => R5) | ((...p: A6) => R6) | ((...p: A7) => R7) | ((...p: A8) => R8) | ((...p: A9) => R9) | ((...p: A10) => R10) : F extends {\n    (...args: infer A1): infer R1;\n    (...args: infer A2): infer R2;\n    (...args: infer A3): infer R3;\n    (...args: infer A4): infer R4;\n    (...args: infer A5): infer R5;\n    (...args: infer A6): infer R6;\n    (...args: infer A7): infer R7;\n    (...args: infer A8): infer R8;\n    (...args: infer A9): infer R9;\n} ? ((...p: A1) => R1) | ((...p: A2) => R2) | ((...p: A3) => R3) | ((...p: A4) => R4) | ((...p: A5) => R5) | ((...p: A6) => R6) | ((...p: A7) => R7) | ((...p: A8) => R8) | ((...p: A9) => R9) : F extends {\n    (...args: infer A1): infer R1;\n    (...args: infer A2): infer R2;\n    (...args: infer A3): infer R3;\n    (...args: infer A4): infer R4;\n    (...args: infer A5): infer R5;\n    (...args: infer A6): infer R6;\n    (...args: infer A7): infer R7;\n    (...args: infer A8): infer R8;\n} ? ((...p: A1) => R1) | ((...p: A2) => R2) | ((...p: A3) => R3) | ((...p: A4) => R4) | ((...p: A5) => R5) | ((...p: A6) => R6) | ((...p: A7) => R7) | ((...p: A8) => R8) : F extends {\n    (...args: infer A1): infer R1;\n    (...args: infer A2): infer R2;\n    (...args: infer A3): infer R3;\n    (...args: infer A4): infer R4;\n    (...args: infer A5): infer R5;\n    (...args: infer A6): infer R6;\n    (...args: infer A7): infer R7;\n} ? ((...p: A1) => R1) | ((...p: A2) => R2) | ((...p: A3) => R3) | ((...p: A4) => R4) | ((...p: A5) => R5) | ((...p: A6) => R6) | ((...p: A7) => R7) : F extends {\n    (...args: infer A1): infer R1;\n    (...args: infer A2): infer R2;\n    (...args: infer A3): infer R3;\n    (...args: infer A4): infer R4;\n    (...args: infer A5): infer R5;\n    (...args: infer A6): infer R6;\n} ? ((...p: A1) => R1) | ((...p: A2) => R2) | ((...p: A3) => R3) | ((...p: A4) => R4) | ((...p: A5) => R5) | ((...p: A6) => R6) : F extends {\n    (...args: infer A1): infer R1;\n    (...args: infer A2): infer R2;\n    (...args: infer A3): infer R3;\n    (...args: infer A4): infer R4;\n    (...args: infer A5): infer R5;\n} ? ((...p: A1) => R1) | ((...p: A2) => R2) | ((...p: A3) => R3) | ((...p: A4) => R4) | ((...p: A5) => R5) : F extends {\n    (...args: infer A1): infer R1;\n    (...args: infer A2): infer R2;\n    (...args: infer A3): infer R3;\n    (...args: infer A4): infer R4;\n} ? ((...p: A1) => R1) | ((...p: A2) => R2) | ((...p: A3) => R3) | ((...p: A4) => R4) : F extends {\n    (...args: infer A1): infer R1;\n    (...args: infer A2): infer R2;\n    (...args: infer A3): infer R3;\n} ? ((...p: A1) => R1) | ((...p: A2) => R2) | ((...p: A3) => R3) : F extends {\n    (...args: infer A1): infer R1;\n    (...args: infer A2): infer R2;\n} ? ((...p: A1) => R1) | ((...p: A2) => R2) : F extends (...args: infer A1) => infer R1 ? ((...p: A1) => R1) : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "DecreasingOverloadsInfoUnion",
          "typeParameters": [
            {
              "typeParameterName": "F",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!DeepBrand:type",
          "docComment": "/**\n * Represents a deeply branded type.\n *\n * Recursively walk a type and replace it with a branded type related to the original. This is useful for equality-checking stricter than `A extends B ? B extends A ? true : false : false`, because it detects the difference between a few edge-case types that vanilla TypeScript doesn't by default: - `any` vs `unknown` - `{ readonly a: string }` vs `{ a: string }` - `{ a?: string }` vs `{ a: string | undefined }`\n *\n * __Note__: not very performant for complex types - this should only be used when you know you need it. If doing an equality check, it's almost always better to use {@linkcode StrictEqualUsingTSInternalIdenticalToOperator}.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type DeepBrand<T> = "
            },
            {
              "kind": "Reference",
              "text": "IsNever",
              "canonicalReference": "expect-type!IsNever:type"
            },
            {
              "kind": "Content",
              "text": "<T> extends true ? {\n    type: 'never';\n} : "
            },
            {
              "kind": "Reference",
              "text": "IsAny",
              "canonicalReference": "expect-type!IsAny:type"
            },
            {
              "kind": "Content",
              "text": "<T> extends true ? {\n    type: 'any';\n} : "
            },
            {
              "kind": "Reference",
              "text": "IsUnknown",
              "canonicalReference": "expect-type!IsUnknown:type"
            },
            {
              "kind": "Content",
              "text": "<T> extends true ? {\n    type: 'unknown';\n} : T extends string | number | boolean | symbol | bigint | null | undefined | void ? {\n    type: 'primitive';\n    value: T;\n} : T extends new (...args: any[]) => any ? {\n    type: 'constructor';\n    params: "
            },
            {
              "kind": "Reference",
              "text": "ConstructorOverloadParameters",
              "canonicalReference": "expect-type!ConstructorOverloadParameters:type"
            },
            {
              "kind": "Content",
              "text": "<T>;\n    instance: "
            },
            {
              "kind": "Reference",
              "text": "DeepBrand",
              "canonicalReference": "expect-type!DeepBrand:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "InstanceType",
              "canonicalReference": "!InstanceType:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Extract",
              "canonicalReference": "!Extract:type"
            },
            {
              "kind": "Content",
              "text": "<T, new (...args: any) => any>>>;\n} : T extends (...args: infer P) => infer R ? "
            },
            {
              "kind": "Reference",
              "text": "NumOverloads",
              "canonicalReference": "expect-type!NumOverloads:type"
            },
            {
              "kind": "Content",
              "text": "<T> extends 1 ? {\n    type: 'function';\n    params: "
            },
            {
              "kind": "Reference",
              "text": "DeepBrand",
              "canonicalReference": "expect-type!DeepBrand:type"
            },
            {
              "kind": "Content",
              "text": "<P>;\n    return: "
            },
            {
              "kind": "Reference",
              "text": "DeepBrand",
              "canonicalReference": "expect-type!DeepBrand:type"
            },
            {
              "kind": "Content",
              "text": "<R>;\n    this: "
            },
            {
              "kind": "Reference",
              "text": "DeepBrand",
              "canonicalReference": "expect-type!DeepBrand:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "ThisParameterType",
              "canonicalReference": "!ThisParameterType:type"
            },
            {
              "kind": "Content",
              "text": "<T>>;\n    props: "
            },
            {
              "kind": "Reference",
              "text": "DeepBrand",
              "canonicalReference": "expect-type!DeepBrand:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Omit",
              "canonicalReference": "!Omit:type"
            },
            {
              "kind": "Content",
              "text": "<T, keyof "
            },
            {
              "kind": "Reference",
              "text": "Function",
              "canonicalReference": "!Function:interface"
            },
            {
              "kind": "Content",
              "text": ">>;\n} : "
            },
            {
              "kind": "Reference",
              "text": "UnionToTuple",
              "canonicalReference": "expect-type!UnionToTuple:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "OverloadsInfoUnion",
              "canonicalReference": "expect-type!OverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<T>> extends infer OverloadsTuple ? {\n    type: 'overloads';\n    overloads: {\n        [K in keyof OverloadsTuple]: "
            },
            {
              "kind": "Reference",
              "text": "DeepBrand",
              "canonicalReference": "expect-type!DeepBrand:type"
            },
            {
              "kind": "Content",
              "text": "<OverloadsTuple[K]>;\n    };\n} : never : T extends any[] ? {\n    type: 'array';\n    items: {\n        [K in keyof T]: T[K];\n    };\n} : {\n    type: 'object';\n    properties: {\n        [K in keyof T]: "
            },
            {
              "kind": "Reference",
              "text": "DeepBrand",
              "canonicalReference": "expect-type!DeepBrand:type"
            },
            {
              "kind": "Content",
              "text": "<T[K]>;\n    };\n    readonly: "
            },
            {
              "kind": "Reference",
              "text": "ReadonlyKeys",
              "canonicalReference": "expect-type!ReadonlyKeys:type"
            },
            {
              "kind": "Content",
              "text": "<T>;\n    required: "
            },
            {
              "kind": "Reference",
              "text": "RequiredKeys",
              "canonicalReference": "expect-type!RequiredKeys:type"
            },
            {
              "kind": "Content",
              "text": "<T>;\n    optional: "
            },
            {
              "kind": "Reference",
              "text": "OptionalKeys",
              "canonicalReference": "expect-type!OptionalKeys:type"
            },
            {
              "kind": "Content",
              "text": "<T>;\n    constructorParams: "
            },
            {
              "kind": "Reference",
              "text": "DeepBrand",
              "canonicalReference": "expect-type!DeepBrand:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "ConstructorOverloadParameters",
              "canonicalReference": "expect-type!ConstructorOverloadParameters:type"
            },
            {
              "kind": "Content",
              "text": "<T>>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/branding.d.ts",
          "releaseTag": "Public",
          "name": "DeepBrand",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 49
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!Eq:type",
          "docComment": "/**\n * Represents an equality type that returns {@linkcode Right} if {@linkcode Left} is `true`, otherwise returns the negation of {@linkcode Right}.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Eq<Left extends "
            },
            {
              "kind": "Content",
              "text": "boolean"
            },
            {
              "kind": "Content",
              "text": ", Right extends "
            },
            {
              "kind": "Content",
              "text": "boolean"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "Left extends true ? Right : "
            },
            {
              "kind": "Reference",
              "text": "Not",
              "canonicalReference": "expect-type!Not:type"
            },
            {
              "kind": "Content",
              "text": "<Right>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "Eq",
          "typeParameters": [
            {
              "typeParameterName": "Left",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "Right",
              "constraintTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 5,
            "endIndex": 8
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectAny:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectAny<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectAny",
              "canonicalReference": "expect-type!~expectAny:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "IsAny",
              "canonicalReference": "expect-type!IsAny:type"
            },
            {
              "kind": "Content",
              "text": "<T>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectAny",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectArray:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectArray<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectArray",
              "canonicalReference": "expect-type!~expectArray:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "ExtendsExcludingAnyOrNever",
              "canonicalReference": "expect-type!ExtendsExcludingAnyOrNever:type"
            },
            {
              "kind": "Content",
              "text": "<T, any[]>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectArray",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectBigInt:type",
          "docComment": "",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectBigInt<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectBigInt",
              "canonicalReference": "expect-type!~expectBigInt:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "ExtendsExcludingAnyOrNever",
              "canonicalReference": "expect-type!ExtendsExcludingAnyOrNever:type"
            },
            {
              "kind": "Content",
              "text": "<T, bigint>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectBigInt",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectBoolean:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectBoolean<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectBoolean",
              "canonicalReference": "expect-type!~expectBoolean:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "ExtendsExcludingAnyOrNever",
              "canonicalReference": "expect-type!ExtendsExcludingAnyOrNever:type"
            },
            {
              "kind": "Content",
              "text": "<T, boolean>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectBoolean",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectFunction:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectFunction<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectFunction",
              "canonicalReference": "expect-type!~expectFunction:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "ExtendsExcludingAnyOrNever",
              "canonicalReference": "expect-type!ExtendsExcludingAnyOrNever:type"
            },
            {
              "kind": "Content",
              "text": "<T, (...args: any[]) => any>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectFunction",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectNever:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectNever<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectNever",
              "canonicalReference": "expect-type!~expectNever:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "IsNever",
              "canonicalReference": "expect-type!IsNever:type"
            },
            {
              "kind": "Content",
              "text": "<T>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectNever",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectNull:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectNull<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectNull",
              "canonicalReference": "expect-type!~expectNull:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "ExtendsExcludingAnyOrNever",
              "canonicalReference": "expect-type!ExtendsExcludingAnyOrNever:type"
            },
            {
              "kind": "Content",
              "text": "<T, null>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectNull",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectNullable:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectNullable<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectNullable",
              "canonicalReference": "expect-type!~expectNullable:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "Not",
              "canonicalReference": "expect-type!Not:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "StrictEqualUsingBranding",
              "canonicalReference": "expect-type!StrictEqualUsingBranding:type"
            },
            {
              "kind": "Content",
              "text": "<T, "
            },
            {
              "kind": "Reference",
              "text": "NonNullable",
              "canonicalReference": "!NonNullable:type"
            },
            {
              "kind": "Content",
              "text": "<T>>>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectNullable",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 10
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectNumber:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectNumber<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectNumber",
              "canonicalReference": "expect-type!~expectNumber:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "ExtendsExcludingAnyOrNever",
              "canonicalReference": "expect-type!ExtendsExcludingAnyOrNever:type"
            },
            {
              "kind": "Content",
              "text": "<T, number>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectNumber",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectObject:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectObject<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectObject",
              "canonicalReference": "expect-type!~expectObject:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "ExtendsExcludingAnyOrNever",
              "canonicalReference": "expect-type!ExtendsExcludingAnyOrNever:type"
            },
            {
              "kind": "Content",
              "text": "<T, object>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectObject",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectString:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectString<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectString",
              "canonicalReference": "expect-type!~expectString:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "ExtendsExcludingAnyOrNever",
              "canonicalReference": "expect-type!ExtendsExcludingAnyOrNever:type"
            },
            {
              "kind": "Content",
              "text": "<T, string>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectString",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectSymbol:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectSymbol<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectSymbol",
              "canonicalReference": "expect-type!~expectSymbol:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "ExtendsExcludingAnyOrNever",
              "canonicalReference": "expect-type!ExtendsExcludingAnyOrNever:type"
            },
            {
              "kind": "Content",
              "text": "<T, symbol>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectSymbol",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectTypeOf:type",
          "docComment": "/**\n * Represents a conditional type that selects either {@linkcode PositiveExpectTypeOf} or {@linkcode NegativeExpectTypeOf} based on the value of the `positive` property in the {@linkcode Options} type.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectTypeOf<Actual, Options extends "
            },
            {
              "kind": "Content",
              "text": "{\n    positive: boolean;\n}"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "Options['positive'] extends true ? "
            },
            {
              "kind": "Reference",
              "text": "PositiveExpectTypeOf",
              "canonicalReference": "expect-type!PositiveExpectTypeOf:interface"
            },
            {
              "kind": "Content",
              "text": "<Actual> : "
            },
            {
              "kind": "Reference",
              "text": "NegativeExpectTypeOf",
              "canonicalReference": "expect-type!NegativeExpectTypeOf:interface"
            },
            {
              "kind": "Content",
              "text": "<Actual>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/index.d.ts",
          "releaseTag": "Public",
          "name": "ExpectTypeOf",
          "typeParameters": [
            {
              "typeParameterName": "Actual",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "Options",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 3,
            "endIndex": 8
          }
        },
        {
          "kind": "Variable",
          "canonicalReference": "expect-type!expectTypeOf:var",
          "docComment": "/**\n * Similar to Jest's `expect`, but with type-awareness. Gives you access to a number of type-matchers that let you make assertions about the form of a reference or generic type parameter.\n *\n * @example\n * ```ts\n * import { foo, bar } from '../foo'\n * import { expectTypeOf } from 'expect-type'\n *\n * test('foo types', () => {\n *   // make sure `foo` has type { a: number }\n *   expectTypeOf(foo).toMatchTypeOf({ a: 1 })\n *   expectTypeOf(foo).toHaveProperty('a').toBeNumber()\n *\n *   // make sure `bar` is a function taking a string:\n *   expectTypeOf(bar).parameter(0).toBeString()\n *   expectTypeOf(bar).returns.not.toBeAny()\n * })\n * ```\n *\n * @description\n *\n * See the [full docs](https://npmjs.com/package/expect-type#documentation) for lots more examples.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "expectTypeOf: "
            },
            {
              "kind": "Reference",
              "text": "_ExpectTypeOf",
              "canonicalReference": "expect-type!_ExpectTypeOf:type"
            }
          ],
          "fileUrlPath": "dist/index.d.ts",
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "expectTypeOf",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Interface",
          "canonicalReference": "expect-type!ExpectTypeOfOptions:interface",
          "docComment": "/**\n * Represents the options for the {@linkcode ExpectTypeOf} function.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface ExpectTypeOfOptions "
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "ExpectTypeOfOptions",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!ExpectTypeOfOptions#branded:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "branded: "
                },
                {
                  "kind": "Content",
                  "text": "boolean"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "branded",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!ExpectTypeOfOptions#positive:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "positive: "
                },
                {
                  "kind": "Content",
                  "text": "boolean"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "positive",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            }
          ],
          "extendsTokenRanges": []
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectUndefined:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectUndefined<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectUndefined",
              "canonicalReference": "expect-type!~expectUndefined:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "ExtendsExcludingAnyOrNever",
              "canonicalReference": "expect-type!ExtendsExcludingAnyOrNever:type"
            },
            {
              "kind": "Content",
              "text": "<T, undefined>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectUndefined",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectUnknown:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectUnknown<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectUnknown",
              "canonicalReference": "expect-type!~expectUnknown:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "IsUnknown",
              "canonicalReference": "expect-type!IsUnknown:type"
            },
            {
              "kind": "Content",
              "text": "<T>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectUnknown",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExpectVoid:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExpectVoid<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "expectVoid",
              "canonicalReference": "expect-type!~expectVoid:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n    result: "
            },
            {
              "kind": "Reference",
              "text": "ExtendsExcludingAnyOrNever",
              "canonicalReference": "expect-type!ExtendsExcludingAnyOrNever:type"
            },
            {
              "kind": "Content",
              "text": "<T, void>;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "ExpectVoid",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!Extends:type",
          "docComment": "/**\n * Checks if one type extends another. Note: this is not quite the same as `Left extends Right` because: 1. If either type is `never`, the result is `true` iff the other type is also `never`. 2. Types are wrapped in a 1-tuple so that union types are not distributed - instead we consider `string | number` to _not_ extend `number`. If we used `Left extends Right` directly you would get `Extends<string | number, number>` =\\> `false | true` =\\> `boolean`.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Extends<Left, Right> = "
            },
            {
              "kind": "Reference",
              "text": "IsNever",
              "canonicalReference": "expect-type!IsNever:type"
            },
            {
              "kind": "Content",
              "text": "<Left> extends true ? "
            },
            {
              "kind": "Reference",
              "text": "IsNever",
              "canonicalReference": "expect-type!IsNever:type"
            },
            {
              "kind": "Content",
              "text": "<Right> : [Left] extends [Right] ? true : false"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "Extends",
          "typeParameters": [
            {
              "typeParameterName": "Left",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "Right",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ExtendsExcludingAnyOrNever:type",
          "docComment": "/**\n * Checks if the {@linkcode Left} type extends the {@linkcode Right} type, excluding `any` or `never`.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ExtendsExcludingAnyOrNever<Left, Right> = "
            },
            {
              "kind": "Reference",
              "text": "IsAny",
              "canonicalReference": "expect-type!IsAny:type"
            },
            {
              "kind": "Content",
              "text": "<Left> extends true ? "
            },
            {
              "kind": "Reference",
              "text": "IsAny",
              "canonicalReference": "expect-type!IsAny:type"
            },
            {
              "kind": "Content",
              "text": "<Right> : "
            },
            {
              "kind": "Reference",
              "text": "Extends",
              "canonicalReference": "expect-type!Extends:type"
            },
            {
              "kind": "Content",
              "text": "<Left, Right>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "ExtendsExcludingAnyOrNever",
          "typeParameters": [
            {
              "typeParameterName": "Left",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "Right",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!InferConstructor:type",
          "docComment": "/**\n * Allows inferring any constructor using the `infer` keyword.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type InferConstructor<ConstructorType extends "
            },
            {
              "kind": "Content",
              "text": "new (...args: any) => any"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "ConstructorType"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "InferConstructor",
          "typeParameters": [
            {
              "typeParameterName": "ConstructorType",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 3,
            "endIndex": 4
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!InferFunctionType:type",
          "docComment": "/**\n * Allows inferring any function using the `infer` keyword.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type InferFunctionType<FunctionType extends "
            },
            {
              "kind": "Content",
              "text": "(...args: any) => any"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "FunctionType"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "InferFunctionType",
          "typeParameters": [
            {
              "typeParameterName": "FunctionType",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 3,
            "endIndex": 4
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!Inverted:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Inverted<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "inverted",
              "canonicalReference": "expect-type!~inverted:var"
            },
            {
              "kind": "Content",
              "text": "]: T;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "Inverted",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 4
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!IsAny:type",
          "docComment": "/**\n * Checks if the given type is `any`.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type IsAny<T> = "
            },
            {
              "kind": "Content",
              "text": "[T] extends ["
            },
            {
              "kind": "Reference",
              "text": "Secret",
              "canonicalReference": "expect-type!Secret:type"
            },
            {
              "kind": "Content",
              "text": "] ? "
            },
            {
              "kind": "Reference",
              "text": "Not",
              "canonicalReference": "expect-type!Not:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "IsNever",
              "canonicalReference": "expect-type!IsNever:type"
            },
            {
              "kind": "Content",
              "text": "<T>> : false"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "IsAny",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 8
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!IsNever:type",
          "docComment": "/**\n * Checks if the given type is `never`.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type IsNever<T> = "
            },
            {
              "kind": "Content",
              "text": "[T] extends [never] ? true : false"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "IsNever",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!IsNeverOrAny:type",
          "docComment": "/**\n * Determines if a type is either `never` or `any`.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type IsNeverOrAny<T> = "
            },
            {
              "kind": "Reference",
              "text": "Or",
              "canonicalReference": "expect-type!Or:type"
            },
            {
              "kind": "Content",
              "text": "<["
            },
            {
              "kind": "Reference",
              "text": "IsNever",
              "canonicalReference": "expect-type!IsNever:type"
            },
            {
              "kind": "Content",
              "text": "<T>, "
            },
            {
              "kind": "Reference",
              "text": "IsAny",
              "canonicalReference": "expect-type!IsAny:type"
            },
            {
              "kind": "Content",
              "text": "<T>]>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "IsNeverOrAny",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!IsUnknown:type",
          "docComment": "/**\n * Determines if the given type is `unknown`.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type IsUnknown<T> = "
            },
            {
              "kind": "Content",
              "text": "[unknown] extends [T] ? "
            },
            {
              "kind": "Reference",
              "text": "Not",
              "canonicalReference": "expect-type!Not:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "IsAny",
              "canonicalReference": "expect-type!IsAny:type"
            },
            {
              "kind": "Content",
              "text": "<T>> : false"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "IsUnknown",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!IsUselessConstructorOverloadInfo:type",
          "docComment": "/**\n * Same as {@linkcode IsUselessOverloadInfo}, but for constructors.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type IsUselessConstructorOverloadInfo<FunctionType> = "
            },
            {
              "kind": "Reference",
              "text": "StrictEqualUsingTSInternalIdenticalToOperator",
              "canonicalReference": "expect-type!StrictEqualUsingTSInternalIdenticalToOperator:type"
            },
            {
              "kind": "Content",
              "text": "<FunctionType, "
            },
            {
              "kind": "Reference",
              "text": "UnknownConstructor",
              "canonicalReference": "expect-type!UnknownConstructor:type"
            },
            {
              "kind": "Content",
              "text": ">"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "IsUselessConstructorOverloadInfo",
          "typeParameters": [
            {
              "typeParameterName": "FunctionType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!IsUselessOverloadInfo:type",
          "docComment": "/**\n * `true` iff {@linkcode FunctionType} is equivalent to `(...args: unknown[]) => unknown`, which is what an overload variant looks like for a non-existent overload. This is useful because older versions of TypeScript end up with 9 \"useless\" overloads and one real one for parameterless/generic functions.\n *\n * @see\n *\n * {@link https://github.com/microsoft/TypeScript/issues/28867 | Related}\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type IsUselessOverloadInfo<FunctionType> = "
            },
            {
              "kind": "Reference",
              "text": "StrictEqualUsingTSInternalIdenticalToOperator",
              "canonicalReference": "expect-type!StrictEqualUsingTSInternalIdenticalToOperator:type"
            },
            {
              "kind": "Content",
              "text": "<FunctionType, "
            },
            {
              "kind": "Reference",
              "text": "UnknownFunction",
              "canonicalReference": "expect-type!UnknownFunction:type"
            },
            {
              "kind": "Content",
              "text": ">"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "IsUselessOverloadInfo",
          "typeParameters": [
            {
              "typeParameterName": "FunctionType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!LastOf:type",
          "docComment": "/**\n * Get the last element of a union. First, converts to a union of `() => T` functions, then uses {@linkcode UnionToIntersection} to get the last one.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type LastOf<Union> = "
            },
            {
              "kind": "Reference",
              "text": "UnionToIntersection",
              "canonicalReference": "expect-type!UnionToIntersection:type"
            },
            {
              "kind": "Content",
              "text": "<Union extends any ? () => Union : never> extends () => infer R ? R : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "LastOf",
          "typeParameters": [
            {
              "typeParameterName": "Union",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!Mismatch:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Mismatch = "
            },
            {
              "kind": "Content",
              "text": "{\n    ["
            },
            {
              "kind": "Reference",
              "text": "mismatch",
              "canonicalReference": "expect-type!~mismatch:var"
            },
            {
              "kind": "Content",
              "text": "]: 'mismatch';\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "Mismatch",
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 4
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!MismatchArgs:type",
          "docComment": "/**\n * Represents the type of mismatched arguments between the actual result and the expected result.\n *\n * If {@linkcode ActualResult} and {@linkcode ExpectedResult} are equivalent, the type resolves to an empty tuple `[]`, indicating no mismatch. If they are not equivalent, it resolves to a tuple containing the element {@linkcode Mismatch}, signifying a discrepancy between the expected and actual results.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type MismatchArgs<ActualResult extends "
            },
            {
              "kind": "Content",
              "text": "boolean"
            },
            {
              "kind": "Content",
              "text": ", ExpectedResult extends "
            },
            {
              "kind": "Content",
              "text": "boolean"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Reference",
              "text": "Eq",
              "canonicalReference": "expect-type!Eq:type"
            },
            {
              "kind": "Content",
              "text": "<ActualResult, ExpectedResult> extends true ? [] : ["
            },
            {
              "kind": "Reference",
              "text": "Mismatch",
              "canonicalReference": "expect-type!Mismatch:type"
            },
            {
              "kind": "Content",
              "text": "]"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "MismatchArgs",
          "typeParameters": [
            {
              "typeParameterName": "ActualResult",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "ExpectedResult",
              "constraintTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 5,
            "endIndex": 9
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!MismatchInfo:type",
          "docComment": "/**\n * Helper for showing end-user a hint why their type assertion is failing. This swaps \"leaf\" types with a literal message about what the actual and expected types are. Needs to check for `Not<IsAny<Actual>>` because otherwise `LeafTypeOf<Actual>` returns `never`, which extends everything \n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type MismatchInfo<Actual, Expected> = "
            },
            {
              "kind": "Reference",
              "text": "And",
              "canonicalReference": "expect-type!And:type"
            },
            {
              "kind": "Content",
              "text": "<["
            },
            {
              "kind": "Reference",
              "text": "Extends",
              "canonicalReference": "expect-type!Extends:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "PrintType",
              "canonicalReference": "expect-type!PrintType:type"
            },
            {
              "kind": "Content",
              "text": "<Actual>, '...'>, "
            },
            {
              "kind": "Reference",
              "text": "Not",
              "canonicalReference": "expect-type!Not:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "IsAny",
              "canonicalReference": "expect-type!IsAny:type"
            },
            {
              "kind": "Content",
              "text": "<Actual>>]> extends true ? "
            },
            {
              "kind": "Reference",
              "text": "And",
              "canonicalReference": "expect-type!And:type"
            },
            {
              "kind": "Content",
              "text": "<["
            },
            {
              "kind": "Reference",
              "text": "Extends",
              "canonicalReference": "expect-type!Extends:type"
            },
            {
              "kind": "Content",
              "text": "<any[], Actual>, "
            },
            {
              "kind": "Reference",
              "text": "Extends",
              "canonicalReference": "expect-type!Extends:type"
            },
            {
              "kind": "Content",
              "text": "<any[], Expected>]> extends true ? "
            },
            {
              "kind": "Reference",
              "text": "Array",
              "canonicalReference": "!Array:interface"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "MismatchInfo",
              "canonicalReference": "expect-type!MismatchInfo:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Extract",
              "canonicalReference": "!Extract:type"
            },
            {
              "kind": "Content",
              "text": "<Actual, any[]>[number], "
            },
            {
              "kind": "Reference",
              "text": "Extract",
              "canonicalReference": "!Extract:type"
            },
            {
              "kind": "Content",
              "text": "<Expected, any[]>[number]>> : {\n    [K in "
            },
            {
              "kind": "Reference",
              "text": "UsefulKeys",
              "canonicalReference": "expect-type!UsefulKeys:type"
            },
            {
              "kind": "Content",
              "text": "<Actual> | "
            },
            {
              "kind": "Reference",
              "text": "UsefulKeys",
              "canonicalReference": "expect-type!UsefulKeys:type"
            },
            {
              "kind": "Content",
              "text": "<Expected>]: "
            },
            {
              "kind": "Reference",
              "text": "MismatchInfo",
              "canonicalReference": "expect-type!MismatchInfo:type"
            },
            {
              "kind": "Content",
              "text": "<K extends keyof Actual ? Actual[K] : never, K extends keyof Expected ? Expected[K] : never>;\n} : "
            },
            {
              "kind": "Reference",
              "text": "StrictEqualUsingBranding",
              "canonicalReference": "expect-type!StrictEqualUsingBranding:type"
            },
            {
              "kind": "Content",
              "text": "<Actual, Expected> extends true ? Actual : `Expected: ${"
            },
            {
              "kind": "Reference",
              "text": "PrintType",
              "canonicalReference": "expect-type!PrintType:type"
            },
            {
              "kind": "Content",
              "text": "<Expected>}, Actual: ${"
            },
            {
              "kind": "Reference",
              "text": "PrintType",
              "canonicalReference": "expect-type!PrintType:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Exclude",
              "canonicalReference": "!Exclude:type"
            },
            {
              "kind": "Content",
              "text": "<Actual, Expected>>}`"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "MismatchInfo",
          "typeParameters": [
            {
              "typeParameterName": "Actual",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "Expected",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 39
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!MutuallyExtends:type",
          "docComment": "/**\n * Checks that {@linkcode Left} and {@linkcode Right} extend each other. Not quite the same as an equality check since `any` can make it resolve to `true`. So should only be used when {@linkcode Left} and {@linkcode Right} are known to avoid `any`.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type MutuallyExtends<Left, Right> = "
            },
            {
              "kind": "Reference",
              "text": "And",
              "canonicalReference": "expect-type!And:type"
            },
            {
              "kind": "Content",
              "text": "<["
            },
            {
              "kind": "Reference",
              "text": "Extends",
              "canonicalReference": "expect-type!Extends:type"
            },
            {
              "kind": "Content",
              "text": "<Left, Right>, "
            },
            {
              "kind": "Reference",
              "text": "Extends",
              "canonicalReference": "expect-type!Extends:type"
            },
            {
              "kind": "Content",
              "text": "<Right, Left>]>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "MutuallyExtends",
          "typeParameters": [
            {
              "typeParameterName": "Left",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "Right",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "Interface",
          "canonicalReference": "expect-type!NegativeExpectTypeOf:interface",
          "docComment": "/**\n * Represents the negative expectation type for the {@linkcode Actual} type.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface NegativeExpectTypeOf<Actual> extends "
            },
            {
              "kind": "Reference",
              "text": "BaseExpectTypeOf",
              "canonicalReference": "expect-type!BaseExpectTypeOf:interface"
            },
            {
              "kind": "Content",
              "text": "<Actual, {\n    positive: false;\n}>"
            },
            {
              "kind": "Content",
              "text": " "
            }
          ],
          "fileUrlPath": "dist/index.d.ts",
          "releaseTag": "Public",
          "typeParameters": [
            {
              "typeParameterName": "Actual",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "NegativeExpectTypeOf",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!NegativeExpectTypeOf#positive:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "positive: "
                },
                {
                  "kind": "Content",
                  "text": "false"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "positive",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!NegativeExpectTypeOf#toEqualTypeOf:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toEqualTypeOf: "
                },
                {
                  "kind": "Content",
                  "text": "{\n        <Expected>(value: Expected & "
                },
                {
                  "kind": "Reference",
                  "text": "AValue",
                  "canonicalReference": "expect-type!AValue:type"
                },
                {
                  "kind": "Content",
                  "text": ", ...MISMATCH: "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchArgs",
                  "canonicalReference": "expect-type!MismatchArgs:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "StrictEqualUsingTSInternalIdenticalToOperator",
                  "canonicalReference": "expect-type!StrictEqualUsingTSInternalIdenticalToOperator:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected>, false>): true;\n        <Expected>(...MISMATCH: "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchArgs",
                  "canonicalReference": "expect-type!MismatchArgs:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "StrictEqualUsingTSInternalIdenticalToOperator",
                  "canonicalReference": "expect-type!StrictEqualUsingTSInternalIdenticalToOperator:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected>, false>): true;\n    }"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toEqualTypeOf",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 12
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!NegativeExpectTypeOf#toHaveProperty:member",
              "docComment": "/**\n * Checks whether an object has a given property.\n *\n * @param key - The property key to check for.\n *\n * @param MISMATCH - The mismatch arguments.\n *\n * @returns `true`.\n *\n * @example\n *\n * <caption>check that properties exist</caption>\n * ```ts\n * const obj = { a: 1, b: '' }\n *\n * expectTypeOf(obj).toHaveProperty('a')\n *\n * expectTypeOf(obj).not.toHaveProperty('c')\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toHaveProperty: "
                },
                {
                  "kind": "Content",
                  "text": "<KeyType extends string | number | symbol>(key: KeyType, ...MISMATCH: "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchArgs",
                  "canonicalReference": "expect-type!MismatchArgs:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Extends",
                  "canonicalReference": "expect-type!Extends:type"
                },
                {
                  "kind": "Content",
                  "text": "<KeyType, keyof Actual>, false>) => true"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toHaveProperty",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 6
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!NegativeExpectTypeOf#toMatchTypeOf:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toMatchTypeOf: "
                },
                {
                  "kind": "Content",
                  "text": "{\n        <Expected>(value: Expected & "
                },
                {
                  "kind": "Reference",
                  "text": "AValue",
                  "canonicalReference": "expect-type!AValue:type"
                },
                {
                  "kind": "Content",
                  "text": ", // reason for `& AValue`: make sure this is only the selected overload when the end-user passes a value for an inferred typearg. The `Mismatch` type does match `AValue`.\n        ...MISMATCH: "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchArgs",
                  "canonicalReference": "expect-type!MismatchArgs:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Extends",
                  "canonicalReference": "expect-type!Extends:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected>, false>): true;\n        <Expected>(...MISMATCH: "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchArgs",
                  "canonicalReference": "expect-type!MismatchArgs:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Extends",
                  "canonicalReference": "expect-type!Extends:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected>, false>): true;\n    }"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toMatchTypeOf",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 12
              }
            }
          ],
          "extendsTokenRanges": [
            {
              "startIndex": 1,
              "endIndex": 3
            }
          ]
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!Not:type",
          "docComment": "/**\n * Negates a boolean type.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Not<T extends "
            },
            {
              "kind": "Content",
              "text": "boolean"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "T extends true ? false : true"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "Not",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 3,
            "endIndex": 4
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!NumOverloads:type",
          "docComment": "/**\n * Calculates the number of overloads for a given function type.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type NumOverloads<FunctionType> = "
            },
            {
              "kind": "Reference",
              "text": "UnionToTuple",
              "canonicalReference": "expect-type!UnionToTuple:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "OverloadsInfoUnion",
              "canonicalReference": "expect-type!OverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<FunctionType>>['length']"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "NumOverloads",
          "typeParameters": [
            {
              "typeParameterName": "FunctionType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!OptionalKeys:type",
          "docComment": "/**\n * Gets the keys of an object type that are optional.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type OptionalKeys<T> = "
            },
            {
              "kind": "Reference",
              "text": "Exclude",
              "canonicalReference": "!Exclude:type"
            },
            {
              "kind": "Content",
              "text": "<keyof T, "
            },
            {
              "kind": "Reference",
              "text": "RequiredKeys",
              "canonicalReference": "expect-type!RequiredKeys:type"
            },
            {
              "kind": "Content",
              "text": "<T>>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "OptionalKeys",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!Or:type",
          "docComment": "/**\n * Returns `true` if at least one of the types in the {@linkcode Types} array is `true`, otherwise returns `false`.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Or<Types extends "
            },
            {
              "kind": "Content",
              "text": "boolean[]"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "Types[number] extends false ? false : true"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "Or",
          "typeParameters": [
            {
              "typeParameterName": "Types",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 3,
            "endIndex": 4
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!OverloadParameters:type",
          "docComment": "/**\n * A union type of the parameters allowed for any overload of function {@linkcode FunctionType}.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type OverloadParameters<FunctionType> = "
            },
            {
              "kind": "Reference",
              "text": "OverloadsInfoUnion",
              "canonicalReference": "expect-type!OverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<FunctionType> extends "
            },
            {
              "kind": "Reference",
              "text": "InferFunctionType",
              "canonicalReference": "expect-type!InferFunctionType:type"
            },
            {
              "kind": "Content",
              "text": "<infer Fn> ? "
            },
            {
              "kind": "Reference",
              "text": "Parameters",
              "canonicalReference": "!Parameters:type"
            },
            {
              "kind": "Content",
              "text": "<Fn> : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "OverloadParameters",
          "typeParameters": [
            {
              "typeParameterName": "FunctionType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!OverloadReturnTypes:type",
          "docComment": "/**\n * A union type of the return types for any overload of function {@linkcode FunctionType}.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type OverloadReturnTypes<FunctionType> = "
            },
            {
              "kind": "Reference",
              "text": "OverloadsInfoUnion",
              "canonicalReference": "expect-type!OverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<FunctionType> extends "
            },
            {
              "kind": "Reference",
              "text": "InferFunctionType",
              "canonicalReference": "expect-type!InferFunctionType:type"
            },
            {
              "kind": "Content",
              "text": "<infer Fn> ? "
            },
            {
              "kind": "Reference",
              "text": "ReturnType",
              "canonicalReference": "!ReturnType:type"
            },
            {
              "kind": "Content",
              "text": "<Fn> : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "OverloadReturnTypes",
          "typeParameters": [
            {
              "typeParameterName": "FunctionType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!OverloadsInfoUnion:type",
          "docComment": "/**\n * Get a union of overload variants for a function {@linkcode FunctionType}. Does a check for whether we can do the one-shot 10-overload matcher (which works for ts\\>5.3), and if not, falls back to the more complicated utility.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type OverloadsInfoUnion<FunctionType> = "
            },
            {
              "kind": "Reference",
              "text": "IsNever",
              "canonicalReference": "expect-type!IsNever:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "TSPost53OverloadsInfoUnion",
              "canonicalReference": "expect-type!TSPost53OverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<(a: 1) => 2>> extends true ? "
            },
            {
              "kind": "Reference",
              "text": "TSPre53OverloadsInfoUnion",
              "canonicalReference": "expect-type!TSPre53OverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<FunctionType> : "
            },
            {
              "kind": "Reference",
              "text": "TSPost53OverloadsInfoUnion",
              "canonicalReference": "expect-type!TSPost53OverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<FunctionType>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "OverloadsInfoUnion",
          "typeParameters": [
            {
              "typeParameterName": "FunctionType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 9
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!OverloadsNarrowedByParameters:type",
          "docComment": "/**\n * Creates a new overload (an intersection type) from an existing one, which only includes variant(s) which can accept {@linkcode Args} as parameters.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type OverloadsNarrowedByParameters<FunctionType, Args extends "
            },
            {
              "kind": "Reference",
              "text": "OverloadParameters",
              "canonicalReference": "expect-type!OverloadParameters:type"
            },
            {
              "kind": "Content",
              "text": "<FunctionType>"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Reference",
              "text": "UnionToIntersection",
              "canonicalReference": "expect-type!UnionToIntersection:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "SelectOverloadsInfo",
              "canonicalReference": "expect-type!SelectOverloadsInfo:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "OverloadsInfoUnion",
              "canonicalReference": "expect-type!OverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<FunctionType>, Args>>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "OverloadsNarrowedByParameters",
          "typeParameters": [
            {
              "typeParameterName": "FunctionType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "Args",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 4,
            "endIndex": 10
          }
        },
        {
          "kind": "Interface",
          "canonicalReference": "expect-type!PositiveExpectTypeOf:interface",
          "docComment": "/**\n * Represents the positive assertion methods available for type checking in the {@linkcode expectTypeOf()} utility.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export interface PositiveExpectTypeOf<Actual> extends "
            },
            {
              "kind": "Reference",
              "text": "BaseExpectTypeOf",
              "canonicalReference": "expect-type!BaseExpectTypeOf:interface"
            },
            {
              "kind": "Content",
              "text": "<Actual, {\n    positive: true;\n    branded: false;\n}>"
            },
            {
              "kind": "Content",
              "text": " "
            }
          ],
          "fileUrlPath": "dist/index.d.ts",
          "releaseTag": "Public",
          "typeParameters": [
            {
              "typeParameterName": "Actual",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "PositiveExpectTypeOf",
          "preserveMemberOrder": false,
          "members": [
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!PositiveExpectTypeOf#branded:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "branded: "
                },
                {
                  "kind": "Content",
                  "text": "false"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "branded",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!PositiveExpectTypeOf#not:member",
              "docComment": "/**\n * Inverts the result of the following assertions.\n *\n * @example\n * ```ts\n * expectTypeOf({ a: 1 }).not.toMatchTypeOf({ b: 1 })\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "not: "
                },
                {
                  "kind": "Reference",
                  "text": "NegativeExpectTypeOf",
                  "canonicalReference": "expect-type!NegativeExpectTypeOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<Actual>"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "not",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!PositiveExpectTypeOf#positive:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "positive: "
                },
                {
                  "kind": "Content",
                  "text": "true"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "positive",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!PositiveExpectTypeOf#toEqualTypeOf:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toEqualTypeOf: "
                },
                {
                  "kind": "Content",
                  "text": "{\n        <Expected extends "
                },
                {
                  "kind": "Reference",
                  "text": "StrictEqualUsingTSInternalIdenticalToOperator",
                  "canonicalReference": "expect-type!StrictEqualUsingTSInternalIdenticalToOperator:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected> extends true ? unknown : "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchInfo",
                  "canonicalReference": "expect-type!MismatchInfo:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected>>(value: Expected & "
                },
                {
                  "kind": "Reference",
                  "text": "AValue",
                  "canonicalReference": "expect-type!AValue:type"
                },
                {
                  "kind": "Content",
                  "text": ", // reason for `& AValue`: make sure this is only the selected overload when the end-user passes a value for an inferred typearg. The `Mismatch` type does match `AValue`.\n        ...MISMATCH: "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchArgs",
                  "canonicalReference": "expect-type!MismatchArgs:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "StrictEqualUsingTSInternalIdenticalToOperator",
                  "canonicalReference": "expect-type!StrictEqualUsingTSInternalIdenticalToOperator:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected>, true>): true;\n        <Expected extends "
                },
                {
                  "kind": "Reference",
                  "text": "StrictEqualUsingTSInternalIdenticalToOperator",
                  "canonicalReference": "expect-type!StrictEqualUsingTSInternalIdenticalToOperator:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected> extends true ? unknown : "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchInfo",
                  "canonicalReference": "expect-type!MismatchInfo:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected>>(...MISMATCH: "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchArgs",
                  "canonicalReference": "expect-type!MismatchArgs:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "StrictEqualUsingTSInternalIdenticalToOperator",
                  "canonicalReference": "expect-type!StrictEqualUsingTSInternalIdenticalToOperator:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected>, true>): true;\n    }"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toEqualTypeOf",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 20
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!PositiveExpectTypeOf#toHaveProperty:member",
              "docComment": "/**\n * Checks whether an object has a given property.\n *\n * @param key - The property key to check for.\n *\n * @param MISMATCH - The mismatch arguments.\n *\n * @returns `true`.\n *\n * @example\n *\n * <caption>check that properties exist</caption>\n * ```ts\n * const obj = { a: 1, b: '' }\n *\n * expectTypeOf(obj).toHaveProperty('a')\n *\n * expectTypeOf(obj).not.toHaveProperty('c')\n * ```\n *\n */\n",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toHaveProperty: "
                },
                {
                  "kind": "Content",
                  "text": "<KeyType extends keyof Actual>(key: KeyType, ...MISMATCH: "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchArgs",
                  "canonicalReference": "expect-type!MismatchArgs:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Extends",
                  "canonicalReference": "expect-type!Extends:type"
                },
                {
                  "kind": "Content",
                  "text": "<KeyType, keyof Actual>, true>) => KeyType extends keyof Actual ? "
                },
                {
                  "kind": "Reference",
                  "text": "PositiveExpectTypeOf",
                  "canonicalReference": "expect-type!PositiveExpectTypeOf:interface"
                },
                {
                  "kind": "Content",
                  "text": "<Actual[KeyType]> : true"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toHaveProperty",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 8
              }
            },
            {
              "kind": "PropertySignature",
              "canonicalReference": "expect-type!PositiveExpectTypeOf#toMatchTypeOf:member",
              "docComment": "",
              "excerptTokens": [
                {
                  "kind": "Content",
                  "text": "toMatchTypeOf: "
                },
                {
                  "kind": "Content",
                  "text": "{\n        <Expected extends "
                },
                {
                  "kind": "Reference",
                  "text": "Extends",
                  "canonicalReference": "expect-type!Extends:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected> extends true ? unknown : "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchInfo",
                  "canonicalReference": "expect-type!MismatchInfo:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected>>(value: Expected & "
                },
                {
                  "kind": "Reference",
                  "text": "AValue",
                  "canonicalReference": "expect-type!AValue:type"
                },
                {
                  "kind": "Content",
                  "text": ", // reason for `& AValue`: make sure this is only the selected overload when the end-user passes a value for an inferred typearg. The `Mismatch` type does match `AValue`.\n        ...MISMATCH: "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchArgs",
                  "canonicalReference": "expect-type!MismatchArgs:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Extends",
                  "canonicalReference": "expect-type!Extends:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected>, true>): true;\n        <Expected extends "
                },
                {
                  "kind": "Reference",
                  "text": "Extends",
                  "canonicalReference": "expect-type!Extends:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected> extends true ? unknown : "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchInfo",
                  "canonicalReference": "expect-type!MismatchInfo:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected>>(...MISMATCH: "
                },
                {
                  "kind": "Reference",
                  "text": "MismatchArgs",
                  "canonicalReference": "expect-type!MismatchArgs:type"
                },
                {
                  "kind": "Content",
                  "text": "<"
                },
                {
                  "kind": "Reference",
                  "text": "Extends",
                  "canonicalReference": "expect-type!Extends:type"
                },
                {
                  "kind": "Content",
                  "text": "<Actual, Expected>, true>): true;\n    }"
                },
                {
                  "kind": "Content",
                  "text": ";"
                }
              ],
              "isReadonly": false,
              "isOptional": false,
              "releaseTag": "Public",
              "name": "toMatchTypeOf",
              "propertyTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 20
              }
            }
          ],
          "extendsTokenRanges": [
            {
              "startIndex": 1,
              "endIndex": 3
            }
          ]
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!PrintType:type",
          "docComment": "/**\n * Determines the printable type representation for a given type.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type PrintType<T> = "
            },
            {
              "kind": "Reference",
              "text": "IsUnknown",
              "canonicalReference": "expect-type!IsUnknown:type"
            },
            {
              "kind": "Content",
              "text": "<T> extends true ? 'unknown' : "
            },
            {
              "kind": "Reference",
              "text": "IsNever",
              "canonicalReference": "expect-type!IsNever:type"
            },
            {
              "kind": "Content",
              "text": "<T> extends true ? 'never' : "
            },
            {
              "kind": "Reference",
              "text": "IsAny",
              "canonicalReference": "expect-type!IsAny:type"
            },
            {
              "kind": "Content",
              "text": "<T> extends true ? never : boolean extends T ? 'boolean' : T extends boolean ? `literal boolean: ${T}` : string extends T ? 'string' : T extends string ? `literal string: ${T}` : number extends T ? 'number' : T extends number ? `literal number: ${T}` : bigint extends T ? 'bigint' : T extends bigint ? `literal bigint: ${T}` : T extends null ? 'null' : T extends undefined ? 'undefined' : T extends (...args: any[]) => any ? 'function' : '...'"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "PrintType",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ReadonlyEquivalent:type",
          "docComment": "/**\n * Determines if two types, are equivalent in a `readonly` manner.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ReadonlyEquivalent<X, Y> = "
            },
            {
              "kind": "Reference",
              "text": "Extends",
              "canonicalReference": "expect-type!Extends:type"
            },
            {
              "kind": "Content",
              "text": "<(<T>() => T extends X ? true : false), (<T>() => T extends Y ? true : false)>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "ReadonlyEquivalent",
          "typeParameters": [
            {
              "typeParameterName": "X",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "Y",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!ReadonlyKeys:type",
          "docComment": "/**\n * Extracts the keys from a type that are not `readonly`.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type ReadonlyKeys<T> = "
            },
            {
              "kind": "Reference",
              "text": "Extract",
              "canonicalReference": "!Extract:type"
            },
            {
              "kind": "Content",
              "text": "<{\n    [K in keyof T]-?: "
            },
            {
              "kind": "Reference",
              "text": "ReadonlyEquivalent",
              "canonicalReference": "expect-type!ReadonlyEquivalent:type"
            },
            {
              "kind": "Content",
              "text": "<{\n        [_K in K]: T[K];\n    }, {\n        -readonly [_K in K]: T[K];\n    }> extends true ? never : K;\n}[keyof T], keyof T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "ReadonlyKeys",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!RequiredKeys:type",
          "docComment": "/**\n * Extracts the keys from a type that are required (not optional).\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type RequiredKeys<T> = "
            },
            {
              "kind": "Reference",
              "text": "Extract",
              "canonicalReference": "!Extract:type"
            },
            {
              "kind": "Content",
              "text": "<{\n    [K in keyof T]-?: {} extends "
            },
            {
              "kind": "Reference",
              "text": "Pick",
              "canonicalReference": "!Pick:type"
            },
            {
              "kind": "Content",
              "text": "<T, K> ? never : K;\n}[keyof T], keyof T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "RequiredKeys",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 5
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!Scolder:type",
          "docComment": "/**\n * Checks if the result of an expecter matches the specified options, and resolves to a fairly readable error message if not.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Scolder<Expecter extends "
            },
            {
              "kind": "Content",
              "text": "{\n    result: boolean;\n}"
            },
            {
              "kind": "Content",
              "text": ", Options extends "
            },
            {
              "kind": "Content",
              "text": "{\n    positive: boolean;\n}"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "Expecter['result'] extends Options['positive'] ? () => true : Options['positive'] extends true ? Expecter : "
            },
            {
              "kind": "Reference",
              "text": "Inverted",
              "canonicalReference": "expect-type!Inverted:type"
            },
            {
              "kind": "Content",
              "text": "<Expecter>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/messages.d.ts",
          "releaseTag": "Public",
          "name": "Scolder",
          "typeParameters": [
            {
              "typeParameterName": "Expecter",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "Options",
              "constraintTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 5,
            "endIndex": 8
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!Secret:type",
          "docComment": "/**\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Secret = "
            },
            {
              "kind": "Content",
              "text": "typeof "
            },
            {
              "kind": "Reference",
              "text": "secret",
              "canonicalReference": "expect-type!~secret:var"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "Secret",
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!SelectOverloadsInfo:type",
          "docComment": "/**\n * Takes an overload variants {@linkcode Union}, produced from {@linkcode OverloadsInfoUnion} and rejects the ones incompatible with parameters {@linkcode Args}.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type SelectOverloadsInfo<Union extends "
            },
            {
              "kind": "Reference",
              "text": "UnknownFunction",
              "canonicalReference": "expect-type!UnknownFunction:type"
            },
            {
              "kind": "Content",
              "text": ", Args extends "
            },
            {
              "kind": "Content",
              "text": "unknown[]"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Content",
              "text": "Union extends "
            },
            {
              "kind": "Reference",
              "text": "InferFunctionType",
              "canonicalReference": "expect-type!InferFunctionType:type"
            },
            {
              "kind": "Content",
              "text": "<infer Fn> ? (Args extends "
            },
            {
              "kind": "Reference",
              "text": "Parameters",
              "canonicalReference": "!Parameters:type"
            },
            {
              "kind": "Content",
              "text": "<Fn> ? Fn : never) : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "SelectOverloadsInfo",
          "typeParameters": [
            {
              "typeParameterName": "Union",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "Args",
              "constraintTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 5,
            "endIndex": 10
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!StrictEqualUsingBranding:type",
          "docComment": "/**\n * Checks if two types are strictly equal using branding.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type StrictEqualUsingBranding<Left, Right> = "
            },
            {
              "kind": "Reference",
              "text": "MutuallyExtends",
              "canonicalReference": "expect-type!MutuallyExtends:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "DeepBrand",
              "canonicalReference": "expect-type!DeepBrand:type"
            },
            {
              "kind": "Content",
              "text": "<Left>, "
            },
            {
              "kind": "Reference",
              "text": "DeepBrand",
              "canonicalReference": "expect-type!DeepBrand:type"
            },
            {
              "kind": "Content",
              "text": "<Right>>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/branding.d.ts",
          "releaseTag": "Public",
          "name": "StrictEqualUsingBranding",
          "typeParameters": [
            {
              "typeParameterName": "Left",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "Right",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!StrictEqualUsingTSInternalIdenticalToOperator:type",
          "docComment": "/**\n * Checks if two types are strictly equal using the TypeScript internal identical-to operator.\n *\n * @see\n *\n * {@link https://github.com/microsoft/TypeScript/issues/55188#issuecomment-1656328122 | much history}\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type StrictEqualUsingTSInternalIdenticalToOperator<L, R> = "
            },
            {
              "kind": "Content",
              "text": "(<T>() => T extends (L & T) | T ? true : false) extends <T>() => T extends (R & T) | T ? true : false ? "
            },
            {
              "kind": "Reference",
              "text": "IsNever",
              "canonicalReference": "expect-type!IsNever:type"
            },
            {
              "kind": "Content",
              "text": "<L> extends "
            },
            {
              "kind": "Reference",
              "text": "IsNever",
              "canonicalReference": "expect-type!IsNever:type"
            },
            {
              "kind": "Content",
              "text": "<R> ? true : false : false"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "StrictEqualUsingTSInternalIdenticalToOperator",
          "typeParameters": [
            {
              "typeParameterName": "L",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!TSPost53ConstructorOverloadsInfoUnion:type",
          "docComment": "/**\n * The simple(ish) way to get overload info from a constructor {@linkcode ConstructorType}. Recent versions of TypeScript will match any constructor against a generic 10-overload type, filling in slots with duplicates of the constructor. So, we can just match against a single type and get all the overloads.\n *\n * For older versions of TypeScript, we'll need to painstakingly do ten separate matches.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TSPost53ConstructorOverloadsInfoUnion<ConstructorType> = "
            },
            {
              "kind": "Content",
              "text": "ConstructorType extends {\n    new (...args: infer A1): infer R1;\n    new (...args: infer A2): infer R2;\n    new (...args: infer A3): infer R3;\n    new (...args: infer A4): infer R4;\n    new (...args: infer A5): infer R5;\n    new (...args: infer A6): infer R6;\n    new (...args: infer A7): infer R7;\n    new (...args: infer A8): infer R8;\n    new (...args: infer A9): infer R9;\n    new (...args: infer A10): infer R10;\n} ? (new (...p: A1) => R1) | (new (...p: A2) => R2) | (new (...p: A3) => R3) | (new (...p: A4) => R4) | (new (...p: A5) => R5) | (new (...p: A6) => R6) | (new (...p: A7) => R7) | (new (...p: A8) => R8) | (new (...p: A9) => R9) | (new (...p: A10) => R10) : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "TSPost53ConstructorOverloadsInfoUnion",
          "typeParameters": [
            {
              "typeParameterName": "ConstructorType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!TSPost53OverloadsInfoUnion:type",
          "docComment": "/**\n * The simple(ish) way to get overload info from a function {@linkcode FunctionType}. Recent versions of TypeScript will match any function against a generic 10-overload type, filling in slots with duplicates of the function. So, we can just match against a single type and get all the overloads.\n *\n * For older versions of TypeScript, we'll need to painstakingly do ten separate matches.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TSPost53OverloadsInfoUnion<FunctionType> = "
            },
            {
              "kind": "Content",
              "text": "FunctionType extends {\n    (...args: infer A1): infer R1;\n    (...args: infer A2): infer R2;\n    (...args: infer A3): infer R3;\n    (...args: infer A4): infer R4;\n    (...args: infer A5): infer R5;\n    (...args: infer A6): infer R6;\n    (...args: infer A7): infer R7;\n    (...args: infer A8): infer R8;\n    (...args: infer A9): infer R9;\n    (...args: infer A10): infer R10;\n} ? ((...p: A1) => R1) | ((...p: A2) => R2) | ((...p: A3) => R3) | ((...p: A4) => R4) | ((...p: A5) => R5) | ((...p: A6) => R6) | ((...p: A7) => R7) | ((...p: A8) => R8) | ((...p: A9) => R9) | ((...p: A10) => R10) : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "TSPost53OverloadsInfoUnion",
          "typeParameters": [
            {
              "typeParameterName": "FunctionType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!TSPre53ConstructorOverloadsInfoUnion:type",
          "docComment": "/**\n * For older versions of TypeScript, we need two separate workarounds to get constructor overload info. First, we need need to use {@linkcode DecreasingConstructorOverloadsInfoUnion} to get the overload info for constructors with 1-10 overloads. Then, we need to filter out the \"useless\" overloads that are present in older versions of TypeScript, for parameterless constructors. To do this we use {@linkcode IsUselessConstructorOverloadInfo} to remove useless overloads.\n *\n * @see\n *\n * {@link https://github.com/microsoft/TypeScript/issues/28867 | Related}\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TSPre53ConstructorOverloadsInfoUnion<ConstructorType> = "
            },
            {
              "kind": "Reference",
              "text": "Tuplify",
              "canonicalReference": "expect-type!Tuplify:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "DecreasingConstructorOverloadsInfoUnion",
              "canonicalReference": "expect-type!DecreasingConstructorOverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<ConstructorType>> extends infer Tup ? Tup extends [infer Ctor] ? "
            },
            {
              "kind": "Reference",
              "text": "IsUselessConstructorOverloadInfo",
              "canonicalReference": "expect-type!IsUselessConstructorOverloadInfo:type"
            },
            {
              "kind": "Content",
              "text": "<Ctor> extends true ? never : Ctor : never : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "TSPre53ConstructorOverloadsInfoUnion",
          "typeParameters": [
            {
              "typeParameterName": "ConstructorType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!TSPre53OverloadsInfoUnion:type",
          "docComment": "/**\n * For older versions of TypeScript, we need two separate workarounds to get overload info. First, we need need to use {@linkcode DecreasingOverloadsInfoUnion} to get the overload info for functions with 1-10 overloads. Then, we need to filter out the \"useless\" overloads that are present in older versions of TypeScript, for parameterless functions. To do this we use {@linkcode IsUselessOverloadInfo} to remove useless overloads.\n *\n * @see\n *\n * {@link https://github.com/microsoft/TypeScript/issues/28867 | Related}\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TSPre53OverloadsInfoUnion<FunctionType> = "
            },
            {
              "kind": "Reference",
              "text": "Tuplify",
              "canonicalReference": "expect-type!Tuplify:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "DecreasingOverloadsInfoUnion",
              "canonicalReference": "expect-type!DecreasingOverloadsInfoUnion:type"
            },
            {
              "kind": "Content",
              "text": "<FunctionType>> extends infer Tup ? Tup extends [infer Fn] ? "
            },
            {
              "kind": "Reference",
              "text": "IsUselessOverloadInfo",
              "canonicalReference": "expect-type!IsUselessOverloadInfo:type"
            },
            {
              "kind": "Content",
              "text": "<Fn> extends true ? never : Fn : never : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "TSPre53OverloadsInfoUnion",
          "typeParameters": [
            {
              "typeParameterName": "FunctionType",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 7
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!Tuplify:type",
          "docComment": "/**\n * Old versions of TypeScript can sometimes seem to refuse to separate out union members unless you put them each in a pointless tuple and add an extra `infer X` expression. There may be a better way to work around this problem, but since it's not a problem in newer versions of TypeScript, it's not a priority right now.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Tuplify<Union> = "
            },
            {
              "kind": "Content",
              "text": "Union extends infer X ? [X] : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "Tuplify",
          "typeParameters": [
            {
              "typeParameterName": "Union",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!TuplifyUnion:type",
          "docComment": "/**\n * Intermediate type for {@linkcode UnionToTuple} which pushes the \"last\" union member to the end of a tuple, and recursively prepends the remainder of the union.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type TuplifyUnion<Union, LastElement = "
            },
            {
              "kind": "Reference",
              "text": "LastOf",
              "canonicalReference": "expect-type!LastOf:type"
            },
            {
              "kind": "Content",
              "text": "<Union>"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Reference",
              "text": "IsNever",
              "canonicalReference": "expect-type!IsNever:type"
            },
            {
              "kind": "Content",
              "text": "<Union> extends true ? [] : [..."
            },
            {
              "kind": "Reference",
              "text": "TuplifyUnion",
              "canonicalReference": "expect-type!TuplifyUnion:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Exclude",
              "canonicalReference": "!Exclude:type"
            },
            {
              "kind": "Content",
              "text": "<Union, LastElement>>, LastElement]"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "TuplifyUnion",
          "typeParameters": [
            {
              "typeParameterName": "Union",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "LastElement",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 4,
            "endIndex": 10
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!UnionToIntersection:type",
          "docComment": "/**\n * Convert a union to an intersection. `A | B | C` -\\> `A & B & C`\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type UnionToIntersection<Union> = "
            },
            {
              "kind": "Content",
              "text": "(Union extends any ? (distributedUnion: Union) => void : never) extends (mergedIntersection: infer Intersection) => void ? Intersection : never"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "UnionToIntersection",
          "typeParameters": [
            {
              "typeParameterName": "Union",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!UnionToTuple:type",
          "docComment": "/**\n * Convert a union like `1 | 2 | 3` to a tuple like `[1, 2, 3]`.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type UnionToTuple<Union> = "
            },
            {
              "kind": "Reference",
              "text": "TuplifyUnion",
              "canonicalReference": "expect-type!TuplifyUnion:type"
            },
            {
              "kind": "Content",
              "text": "<Union>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "UnionToTuple",
          "typeParameters": [
            {
              "typeParameterName": "Union",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!UnknownConstructor:type",
          "docComment": "/**\n * A constructor function with `unknown` parameters and return type.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type UnknownConstructor = "
            },
            {
              "kind": "Content",
              "text": "new (...args: unknown[]) => unknown"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "UnknownConstructor",
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!UnknownFunction:type",
          "docComment": "/**\n * A function with `unknown` parameters and return type.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type UnknownFunction = "
            },
            {
              "kind": "Content",
              "text": "(...args: unknown[]) => unknown"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/overloads.d.ts",
          "releaseTag": "Public",
          "name": "UnknownFunction",
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!UsefulKeys:type",
          "docComment": "/**\n * Subjective \"useful\" keys from a type. For objects it's just `keyof` but for tuples/arrays it's the number keys.\n *\n * @example\n * ```ts\n * UsefulKeys<{ a: 1; b: 2 }> // 'a' | 'b'\n *\n * UsefulKeys<['a', 'b']> // '0' | '1'\n *\n * UsefulKeys<string[]> // number\n * ```\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type UsefulKeys<T> = "
            },
            {
              "kind": "Content",
              "text": "T extends any[] ? {\n    [K in keyof T]: K;\n}[number] : keyof T"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "UsefulKeys",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "expect-type!Xor:type",
          "docComment": "/**\n * Represents the exclusive OR operation on a tuple of boolean types. Returns `true` if exactly one of the boolean types is `true`, otherwise returns `false`.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export type Xor<Types extends "
            },
            {
              "kind": "Content",
              "text": "[boolean, boolean]"
            },
            {
              "kind": "Content",
              "text": "> = "
            },
            {
              "kind": "Reference",
              "text": "Not",
              "canonicalReference": "expect-type!Not:type"
            },
            {
              "kind": "Content",
              "text": "<"
            },
            {
              "kind": "Reference",
              "text": "Eq",
              "canonicalReference": "expect-type!Eq:type"
            },
            {
              "kind": "Content",
              "text": "<Types[0], Types[1]>>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "fileUrlPath": "dist/utils.d.ts",
          "releaseTag": "Public",
          "name": "Xor",
          "typeParameters": [
            {
              "typeParameterName": "Types",
              "constraintTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 3,
            "endIndex": 7
          }
        }
      ]
    }
  ]
}
